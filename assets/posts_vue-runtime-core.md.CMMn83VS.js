import{_ as s,b as e,o as t,a5 as l}from"./chunks/framework.CAaOUjTN.js";const a="/assets/Vue3.CuD88LY9.png",u=JSON.parse('{"title":"Vue3 - Runtime Core","description":"","frontmatter":{"title":"Vue3 - Runtime Core","date":"2020-03-09T02:42:19.967Z","tags":["Vue","Vue3"],"license":"CC BY-NC 4.0","read":{"text":"5 min read","minutes":4.065,"time":243900,"words":813}},"headers":[{"level":2,"title":"一图胜千言","slug":"一图胜千言","link":"#一图胜千言","children":[]},{"level":2,"title":"目录结构","slug":"目录结构","link":"#目录结构","children":[]}],"relativePath":"posts/vue-runtime-core.md","filePath":"posts/vue-runtime-core.md"}'),n={name:"posts/vue-runtime-core.md"};function p(r,i,o,h,k,d){return t(),e("div",null,i[0]||(i[0]=[l(`<p>Vue 3.0 系列之 Runtime Core，对应代码版本 <a href="https://github.com/vuejs/vue-next/tree/fb4856b36375fcf3eecaf89f260b272052a0b432" target="_blank" rel="noreferrer">vue-next</a></p><p>这一节的内容太多了，看了两天，也才刚刚把源码读完，还有很多细节的地方没有看。先记录一下从创建一个 App 开始，Vue 做了那些事情吧。这一部分主要包括 各个 hook 的处理，异步依赖的处理以及更新虚拟 Dom 的处理。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes vitesse-dark vitesse-light vp-code" tabindex="0"><code><span class="line"><span style="--shiki-dark:#4D9375;--shiki-light:#1E754F;">import</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> {</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> createApp</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> }</span><span style="--shiki-dark:#4D9375;--shiki-light:#1E754F;"> from</span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;"> &#39;</span><span style="--shiki-dark:#C98A7D;--shiki-light:#B56959;">vue</span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;">&#39;</span></span>
<span class="line"><span style="--shiki-dark:#4D9375;--shiki-light:#1E754F;">import</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> App</span><span style="--shiki-dark:#4D9375;--shiki-light:#1E754F;"> from</span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;"> &#39;</span><span style="--shiki-dark:#C98A7D;--shiki-light:#B56959;">./App.vue</span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-dark:#80A665;--shiki-light:#59873A;">createApp</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">(</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">App</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">).</span><span style="--shiki-dark:#80A665;--shiki-light:#59873A;">mount</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">(</span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;">&#39;</span><span style="--shiki-dark:#C98A7D;--shiki-light:#B56959;">#app</span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;">&#39;</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">)</span></span></code></pre></div><h2 id="一图胜千言" tabindex="-1">一图胜千言 <a class="header-anchor" href="#一图胜千言" aria-label="Permalink to &quot;一图胜千言&quot;">​</a></h2><p>本来想写一些过程的，但是光画脑图，都花了半天时间。还是直接贴脑图结果吧。剩下的发下一篇文章</p><figure><img src="`+a+'" alt="Vue 3" tabindex="0" loading="lazy"><figcaption>Vue 3</figcaption></figure><h2 id="目录结构" tabindex="-1">目录结构 <a class="header-anchor" href="#目录结构" aria-label="Permalink to &quot;目录结构&quot;">​</a></h2><p>对应文件的一些说明</p><ul><li>components: 原生组件 <ul><li>BaseTransition.ts: HOC，Transition 组件，处理 transition 相关 hook</li><li>KeepAlive.ts: HOC，Keep Alive 组件，添加 actived、deactived hook，缓存组件</li><li>Portal.ts: 特殊组件，在 patch 的时候调用 Portal.process 函数</li><li>Suspense.ts: 特殊组件，主要用于处理 setup 为异步函数的情况。在 patch 的时候做特殊处理</li></ul></li><li>helpers: renderer 相关辅助函数 <ul><li>createSlots.ts: 创建 Slot</li><li>renderList.ts: 创建 列表 负责函数</li><li>renderSlot.ts: 创建 Slot VNode</li><li>resolveAssets.ts: 查找当前实例上注册的的 component 或者 directive</li><li>scopeId.ts: SFC 样式作用域 id 管理</li><li>toHandlers.ts: v-on Object 格式的 key 转换成 on* 格式</li><li>useCssModule.ts: 获取当前实例的 css</li><li>useSsrContext.ts: 注入 SSRContext</li></ul></li><li>apiComputed.ts: 代码很少，两行代码，主要用于 track 依赖项</li><li>apiCreateApp.ts: 创建 App 实例，实例相关配置和 mount 操作都在此处</li><li>apiDefineComponent.ts: 嗯...，实现的函数，就一行，统一 component 的定义。其它代码都是为了服务 TypeScript 的 类型处理</li><li>apiInject.ts: 保存自定义变量在当前实例上，并继承父实例的自定义变量，并在需要的时候注入到目标实例(provide/inject)</li><li>apiLifecycle.ts: 向向前实例注入生命周期钩子，SSR 的时候不处理</li><li>apiOptions.ts: 处理 2.x 的组件书写格式，把各个参数以 3.x 的方式处理，生命周期转换成 hook</li><li>apiWatch.ts: 创建 watch，主要执行 source 的 getter，然后在 effect 里面开启 track，这样，就可以采集到所有的依赖项，然后当依赖项更改时，触发 callback</li><li>component.ts: 主要处理 Vue 组件的 setup 函数</li><li>componentProps.ts: 处理传给组件 props ，统一成 NormalizedProp。特殊处理了 boolean 类型的 prop，和 directive 的生命周期 hook</li><li>componentProxy.ts: 定义 componentInternal 的 Proxy</li><li>componentRenderUtils.ts: 创建组件的根节点渲染结果。对比两个 vNode，判断是否需要更新。更新高阶组件的 el 对象</li><li>componentSlots.ts: 对 vNode 的 slots 做统一化处理，统一成 Slot</li><li>directives.ts: 向 vNode 注入 directive 相关处理，以及执行 directive 相关的生命周期 hook</li><li>errorHandling.ts: Vue 错误处理</li><li>h.ts: jsx 的 createElement 函数</li><li>hmr.ts: 调试开发时，动态更新相关内容，build 版本无关</li><li>hydration.ts: 混合应用的相关 Dom 的创建</li><li>index.ts: 入口，负责导出公共 api</li><li>renderer.ts: 主要负责 diff vDom 以及执行 diff 之后的 patch</li><li>scheduler.ts: 任务调度，主要用于在一个 tick 中执行所有数据的更新</li><li>vnode.ts: 创建一个空的 Virtual Node</li><li>warning.ts: 运行时警告提示，报错 vue 自己的 trace</li></ul>',9)]))}const m=s(n,[["render",p]]);export{u as __pageData,m as default};
