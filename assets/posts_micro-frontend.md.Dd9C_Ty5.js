import{_ as i,b as a,o as e,a5 as n}from"./chunks/framework.CAaOUjTN.js";const d=JSON.parse('{"title":"微前端","description":"","frontmatter":{"title":"微前端","date":"2021-05-31T18:03:01.122Z","tags":["Micro Frontend","Web"],"read":{"text":"18 min read","minutes":17.335,"time":1040100,"words":3467}},"headers":[{"level":2,"title":"什么是微前端？","slug":"什么是微前端","link":"#什么是微前端","children":[]},{"level":2,"title":"那么微前端到底解决的是什么问题？","slug":"那么微前端到底解决的是什么问题","link":"#那么微前端到底解决的是什么问题","children":[]},{"level":2,"title":"微前端怎么解决这些问题的？","slug":"微前端怎么解决这些问题的","link":"#微前端怎么解决这些问题的","children":[{"level":3,"title":"npm package / git submodule","slug":"npm-package-git-submodule","link":"#npm-package-git-submodule","children":[]},{"level":3,"title":"iframe","slug":"iframe","link":"#iframe","children":[]},{"level":3,"title":"micro frontend 框架","slug":"micro-frontend-框架","link":"#micro-frontend-框架","children":[]}]},{"level":2,"title":"微前端框架体验","slug":"微前端框架体验","link":"#微前端框架体验","children":[{"level":3,"title":"Luigi","slug":"luigi","link":"#luigi","children":[]},{"level":3,"title":"EMP","slug":"emp","link":"#emp","children":[]},{"level":3,"title":"Single-SPA","slug":"single-spa","link":"#single-spa","children":[]},{"level":3,"title":"QianKun","slug":"qiankun","link":"#qiankun","children":[]},{"level":3,"title":"小结","slug":"小结","link":"#小结","children":[]}]},{"level":2,"title":"微前端需要解决的问题","slug":"微前端需要解决的问题","link":"#微前端需要解决的问题","children":[{"level":3,"title":"服务更新问题","slug":"服务更新问题","link":"#服务更新问题","children":[]},{"level":3,"title":"通信问题","slug":"通信问题","link":"#通信问题","children":[]},{"level":3,"title":"样式隔离问题","slug":"样式隔离问题","link":"#样式隔离问题","children":[]},{"level":3,"title":"环境隔离问题","slug":"环境隔离问题","link":"#环境隔离问题","children":[]}]},{"level":2,"title":"需要微前端吗？","slug":"需要微前端吗","link":"#需要微前端吗","children":[]},{"level":2,"title":"推荐阅读","slug":"推荐阅读","link":"#推荐阅读","children":[]},{"level":2,"title":"参考文献","slug":"参考文献","link":"#参考文献","children":[]}],"relativePath":"posts/micro-frontend.md","filePath":"posts/micro-frontend.md"}'),t={name:"posts/micro-frontend.md"};function l(h,s,r,p,k,o){return e(),a("div",null,s[0]||(s[0]=[n(`<p>本文尝试分享一下「微前端」这个概念，以及目前（2021-06-01）主要的几种实现方案。</p><h2 id="什么是微前端" tabindex="-1">什么是微前端？ <a class="header-anchor" href="#什么是微前端" aria-label="Permalink to &quot;什么是微前端？&quot;">​</a></h2><p>引用一句 <a href="https://micro-frontends.org/" target="_blank" rel="noreferrer">micro-frontends</a> 的一句话</p><blockquote><p>Techniques, strategies and recipes for building <strong>a modern web app</strong> with <strong>multiple teams</strong> that can <strong>ship features independently</strong>.</p></blockquote><p>简单翻译一下，大概意思是：用技术、策略和方法隔离不同 <strong>团队</strong> 开发的 <strong>功能</strong>，并构建 <strong>现代化的 web 应用</strong>。</p><p>经常有听到「微前端框架」这个词，那「微前端」是一门技术？不，微前端并不是一门技术，微前端仅仅是一种手段，通过制定一些标准，合作开发这个项目的团队都遵守这些标准。再通过这些标准整合起来的架构，也就成了「微前端」。</p><h2 id="那么微前端到底解决的是什么问题" tabindex="-1">那么微前端到底解决的是什么问题？ <a class="header-anchor" href="#那么微前端到底解决的是什么问题" aria-label="Permalink to &quot;那么微前端到底解决的是什么问题？&quot;">​</a></h2><p>想想我最初接触微前端，还是第一份正式工作的时候，当时是在一个创业公司，刚刚成立几个月。我进去的时候，公司有两个应用，一个 A 应用，一个 B 应用，分别对应两个域名。现在公司想做整合，把两个应用的功能整合在一起，组合起来，举个栗子。A 应用有两个页面，分别是 A-1，A-2。现在 B 应用，想要 A-1 这个功能，也就是这个页面，而且想要保持同步更新，也就是，只发布一次，就能同时更新 A 应用中的 A-1 和 B 应用中的 A-1。</p><p>当时的想法比较简单，因为公司用的 vue 框架，而 vue 组件可以打包成一个 js 文件。所以，一个简单的做法，就是把 A 应用中所有功能做成组件，然后打包成一个 js 文件，然后在 B 应用中，引用这个 js 文件，取其中的 A-1 组件，这样也就解决了问题。</p><p>其中核心的代码，大概是这样：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes vitesse-dark vitesse-light vp-code" tabindex="0"><code><span class="line"><span style="--shiki-dark:#758575DD;--shiki-light:#A0ADA0;">// &lt;script src=&quot;//xxx.A.js&quot;/&gt;</span></span>
<span class="line"><span style="--shiki-dark:#CB7676;--shiki-light:#AB5959;">const </span><span style="--shiki-dark:#666666;--shiki-light:#999999;">{</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> A1</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> }</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> =</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> window</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">.</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">_A</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-dark:#4D9375;--shiki-light:#1E754F;">export</span><span style="--shiki-dark:#CB7676;--shiki-light:#AB5959;"> const </span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">routes</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> =</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> [</span></span>
<span class="line"><span style="--shiki-dark:#666666;--shiki-light:#999999;">  {</span></span>
<span class="line"><span style="--shiki-dark:#B8A965;--shiki-light:#998418;">    path</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">: </span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;">&#39;</span><span style="--shiki-dark:#C98A7D;--shiki-light:#B56959;">/a-1</span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;">&#39;</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">,</span></span>
<span class="line"><span style="--shiki-dark:#B8A965;--shiki-light:#998418;">    component</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">: </span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">A1</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">,</span></span>
<span class="line"><span style="--shiki-dark:#666666;--shiki-light:#999999;">  },</span></span>
<span class="line"><span style="--shiki-dark:#666666;--shiki-light:#999999;">]</span></span></code></pre></div><p>从这个栗子中，可以看到，解决的问题也就是：如何在一个应用中引入一个不需要自己维护的能力或者功能。</p><p>进而拓展一下，可以理解成，我简单写一个模板，然后配置其中每个模块的功能，这样，一个应用就完成了。每个模板的功能，都交由不同的团队去维护。如果能实现这样的一个工具，那么就能大大的缩短一款产品的开发成本（想想就开心，做梦真好）。</p><p>在写这片文章的时候，有幸读到 <a href="https://www.yuque.com/kuitos/gky7yw/rhduwc" target="_blank" rel="noreferrer">微前端的核心价值</a>。</p><p>文中用了一整个章节来讨论「微前端」的价值，我简单的总结一下文中的概念，大致是：「微前端」解决的是如何让一个应用存活 3-5 年之后，开发者还能继续为其赋能，就像文章结尾所讲。</p><blockquote><p>那么微前端的使命我认为是：「让天下没有短命的控制台」。</p></blockquote><p>至此，我想，你应该大致对「微前端」有了一个了解。接下来就我们就唠嗑一下怎么解决这些问题。</p><h2 id="微前端怎么解决这些问题的" tabindex="-1">微前端怎么解决这些问题的？ <a class="header-anchor" href="#微前端怎么解决这些问题的" aria-label="Permalink to &quot;微前端怎么解决这些问题的？&quot;">​</a></h2><p>微前端，可看作是「微服务」派生出来的一个概念。也有点像 OOP(Object-Oriented Programing) 中的单一原则（Single Responsibility Principle），一个类、方法只做一件事情。</p><p>讲到一件事情，我们就不得不分析业务，把业务剥离开来，抽成一个一个的服务。然后再通过一些技术手段，来整合不同的服务。</p><p>先简单分享一下我想到的几种方式：</p><ol><li>用 npm package / git submodule 来管理</li><li>用 iframe 加载</li><li>开发 micro frontend 框架</li></ol><h3 id="npm-package-git-submodule" tabindex="-1">npm package / git submodule <a class="header-anchor" href="#npm-package-git-submodule" aria-label="Permalink to &quot;npm package / git submodule&quot;">​</a></h3><p>这种方式，用起来就比较简单，就和用普通的 js 模块一样，除了分离出代码，没有任何其它优势。</p><h3 id="iframe" tabindex="-1">iframe <a class="header-anchor" href="#iframe" aria-label="Permalink to &quot;iframe&quot;">​</a></h3><p>因为 iframe 的特性，天然的隔离性，优势也比较明显：运行环境隔离、独立发布。但同时缺点也很多：加载慢，性能堪忧、隔离性太强，以至于 会话状态共享都成了一个问题。</p><p>整体思考下来，iframe 除了隔离性好之外，也没有什么优势。</p><h3 id="micro-frontend-框架" tabindex="-1">micro frontend 框架 <a class="header-anchor" href="#micro-frontend-框架" aria-label="Permalink to &quot;micro frontend 框架&quot;">​</a></h3><p>框架就有很多啦，不同的框架，优势也各不相同。我选了三个不同的轮子，简单的捋一捋里面的原理。</p><ul><li>Luigi: <a href="https://github.com/SAP/luigi" target="_blank" rel="noreferrer">https://github.com/SAP/luigi</a> ，利用 iframe 构建的微服务框架</li><li>EMP: <a href="https://github.com/efoxTeam/emp" target="_blank" rel="noreferrer">https://github.com/efoxTeam/emp</a> ，使用 webpack5 的 module federation 技术</li><li>Single-SPA: <a href="https://github.com/Single-SPA/Single-SPA" target="_blank" rel="noreferrer">https://github.com/Single-SPA/Single-SPA</a> ，路由框架</li><li>qiankun: <a href="https://github.com/umijs/qiankun" target="_blank" rel="noreferrer">https://github.com/umijs/qiankun</a> ，建立在 Single-SPA 之上的解决方案</li></ul><p>接下来，就看看不同框架之间的优劣。</p><h2 id="微前端框架体验" tabindex="-1">微前端框架体验 <a class="header-anchor" href="#微前端框架体验" aria-label="Permalink to &quot;微前端框架体验&quot;">​</a></h2><p>简单的写写每个框架的处理方式，不一定全对，但一定不会全错 😃。</p><h3 id="luigi" tabindex="-1">Luigi <a class="header-anchor" href="#luigi" aria-label="Permalink to &quot;Luigi&quot;">​</a></h3><p>先看看 <a href="https://github.com/SAP/luigi" target="_blank" rel="noreferrer">Luigi</a>，一个利用 <code>iframe</code> 构建的后台微服务框架。可看作是一个路由框架，主要用于构建后台配置页面。</p><p>通过 <a href="https://docs.luigi-project.io/docs/luigi-core-api?section=luigi-config" target="_blank" rel="noreferrer"><code>Luigi.setConfig</code></a> API 来配置网站的路由、授权、导航、本地化等。然后 <a href="https://github.com/SAP/luigi" target="_blank" rel="noreferrer">Luigi</a> 框架通过 <code>iframe</code> 切换不同的路由。</p><p>消息机制也是通过 <code>window.postMessage</code> 实现，源代码 <a href="https://github.com/SAP/luigi/blob/883c3924cf2ae83fce400cbfd7bf84f8c11359d7/client/src/helpers.js#L111-L119" target="_blank" rel="noreferrer">source</a></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes vitesse-dark vitesse-light vp-code" tabindex="0"><code><span class="line"><span style="--shiki-dark:#80A665;--shiki-light:#59873A;">  sendPostMessageToLuigiCore</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">(</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">msg</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">)</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> {</span></span>
<span class="line"><span style="--shiki-dark:#4D9375;--shiki-light:#1E754F;">    if</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> (</span><span style="--shiki-dark:#C99076;--shiki-light:#A65E2B;">this</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">.</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">origin</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">)</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> {</span></span>
<span class="line"><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">      window</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">.</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">parent</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">.</span><span style="--shiki-dark:#80A665;--shiki-light:#59873A;">postMessage</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">(</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">msg</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">,</span><span style="--shiki-dark:#C99076;--shiki-light:#A65E2B;"> this</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">.</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">origin</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">);</span></span>
<span class="line"><span style="--shiki-dark:#666666;--shiki-light:#999999;">    }</span><span style="--shiki-dark:#4D9375;--shiki-light:#1E754F;"> else</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> {</span></span>
<span class="line"><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">      console</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">.</span><span style="--shiki-dark:#80A665;--shiki-light:#59873A;">warn</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">(</span></span>
<span class="line"><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;">        &#39;</span><span style="--shiki-dark:#C98A7D;--shiki-light:#B56959;">There is no target origin set. You can specify the target origin by calling LuigiClient.setTargetOrigin(&quot;targetorigin&quot;) in your micro frontend.</span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;">&#39;</span></span>
<span class="line"><span style="--shiki-dark:#666666;--shiki-light:#999999;">      );</span></span>
<span class="line"><span style="--shiki-dark:#666666;--shiki-light:#999999;">    }</span></span>
<span class="line"><span style="--shiki-dark:#666666;--shiki-light:#999999;">  }</span></span></code></pre></div><p>路由也是通过封装的 <code>LuigiClient.linkManager</code>、<code>Luigi.navigation</code> 来管理跳转，实际原理也是通过发送消息来实现的，源代码 <a href="https://github.com/SAP/luigi/blob/883c3924cf2ae83fce400cbfd7bf84f8c11359d7/client/src/linkManager.js#L56-L83" target="_blank" rel="noreferrer">source</a></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes vitesse-dark vitesse-light vp-code" tabindex="0"><code><span class="line"><span style="--shiki-dark:#80A665;--shiki-light:#59873A;">  navigate</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">(</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">path</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">,</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> sessionId</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">,</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> preserveView</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">,</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> modalSettings</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">,</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> splitViewSettings</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">,</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> drawerSettings</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">)</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> {</span></span>
<span class="line"><span style="--shiki-dark:#4D9375;--shiki-light:#1E754F;">    if</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> (</span><span style="--shiki-dark:#C99076;--shiki-light:#A65E2B;">this</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">.</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">options</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">.</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">errorSkipNavigation</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">)</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> {</span></span>
<span class="line"><span style="--shiki-dark:#C99076;--shiki-light:#A65E2B;">      this</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">.</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">options</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">.</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">errorSkipNavigation</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> =</span><span style="--shiki-dark:#4D9375;--shiki-light:#1E754F;"> false</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">;</span></span>
<span class="line"><span style="--shiki-dark:#4D9375;--shiki-light:#1E754F;">      return</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">;</span></span>
<span class="line"><span style="--shiki-dark:#666666;--shiki-light:#999999;">    }</span></span>
<span class="line"><span style="--shiki-dark:#4D9375;--shiki-light:#1E754F;">    if</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> (</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">modalSettings</span><span style="--shiki-dark:#CB7676;--shiki-light:#AB5959;"> &amp;&amp;</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> splitViewSettings</span><span style="--shiki-dark:#CB7676;--shiki-light:#AB5959;"> &amp;&amp;</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> drawerSettings</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">)</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> {</span></span>
<span class="line"><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">      console</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">.</span><span style="--shiki-dark:#80A665;--shiki-light:#59873A;">warn</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">(</span></span>
<span class="line"><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;">        &#39;</span><span style="--shiki-dark:#C98A7D;--shiki-light:#B56959;">modalSettings, splitViewSettings and drawerSettings cannot be used together. Only modal setting will be taken into account.</span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;">&#39;</span></span>
<span class="line"><span style="--shiki-dark:#666666;--shiki-light:#999999;">      );</span></span>
<span class="line"><span style="--shiki-dark:#666666;--shiki-light:#999999;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-dark:#C99076;--shiki-light:#A65E2B;">    this</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">.</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">options</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">.</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">preserveView</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> =</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> preserveView</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">;</span></span>
<span class="line"><span style="--shiki-dark:#CB7676;--shiki-light:#AB5959;">    const</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> relativePath</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> =</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> path</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">[</span><span style="--shiki-dark:#4C9A91;--shiki-light:#2F798A;">0</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">]</span><span style="--shiki-dark:#CB7676;--shiki-light:#AB5959;"> !==</span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;"> &#39;</span><span style="--shiki-dark:#C98A7D;--shiki-light:#B56959;">/</span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;">&#39;</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">;</span></span>
<span class="line"><span style="--shiki-dark:#CB7676;--shiki-light:#AB5959;">    const</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> hasIntent</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> =</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> path</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">.</span><span style="--shiki-dark:#80A665;--shiki-light:#59873A;">toLowerCase</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">().</span><span style="--shiki-dark:#80A665;--shiki-light:#59873A;">includes</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">(</span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;">&#39;</span><span style="--shiki-dark:#C98A7D;--shiki-light:#B56959;">?intent=</span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;">&#39;</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">);</span></span>
<span class="line"><span style="--shiki-dark:#CB7676;--shiki-light:#AB5959;">    const</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> navigationOpenMsg</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> =</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> {</span></span>
<span class="line"><span style="--shiki-dark:#B8A965;--shiki-light:#998418;">      msg</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">:</span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;"> &#39;</span><span style="--shiki-dark:#C98A7D;--shiki-light:#B56959;">luigi.navigation.open</span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;">&#39;</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">,</span></span>
<span class="line"><span style="--shiki-dark:#B8A965;--shiki-light:#998418;">      sessionId</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">:</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> sessionId</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">,</span></span>
<span class="line"><span style="--shiki-dark:#B8A965;--shiki-light:#998418;">      params</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">:</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> Object</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">.</span><span style="--shiki-dark:#80A665;--shiki-light:#59873A;">assign</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">(</span><span style="--shiki-dark:#C99076;--shiki-light:#A65E2B;">this</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">.</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">options</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">,</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> {</span></span>
<span class="line"><span style="--shiki-dark:#B8A965;--shiki-light:#998418;">        link</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">:</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> path</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">,</span></span>
<span class="line"><span style="--shiki-dark:#B8A965;--shiki-light:#998418;">        relative</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">:</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> relativePath</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">,</span></span>
<span class="line"><span style="--shiki-dark:#B8A965;--shiki-light:#998418;">        intent</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">:</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> hasIntent</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">,</span></span>
<span class="line"><span style="--shiki-dark:#B8A965;--shiki-light:#998418;">        modal</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">:</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> modalSettings</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">,</span></span>
<span class="line"><span style="--shiki-dark:#B8A965;--shiki-light:#998418;">        splitView</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">:</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> splitViewSettings</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">,</span></span>
<span class="line"><span style="--shiki-dark:#B8A965;--shiki-light:#998418;">        drawer</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">:</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> drawerSettings</span></span>
<span class="line"><span style="--shiki-dark:#666666;--shiki-light:#999999;">      })</span></span>
<span class="line"><span style="--shiki-dark:#666666;--shiki-light:#999999;">    };</span></span>
<span class="line"><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">    helpers</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">.</span><span style="--shiki-dark:#80A665;--shiki-light:#59873A;">sendPostMessageToLuigiCore</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">(</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">navigationOpenMsg</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">);</span></span>
<span class="line"><span style="--shiki-dark:#666666;--shiki-light:#999999;">  }</span></span></code></pre></div><p>其它，如生命周期等，也是类似通过发送消息的方式来实现的。</p><p>整体体验下来，不是特别方便，代码有一定的侵入性。由于 <code>iframe</code> 的特性，每次切换，都要请求一下资源，略慢。</p><p><a href="https://github.com/SAP/luigi" target="_blank" rel="noreferrer">Luigi</a> 体验的差不多了，下一个 <a href="https://github.com/efoxTeam/emp" target="_blank" rel="noreferrer">EMP</a></p><h3 id="emp" tabindex="-1">EMP <a class="header-anchor" href="#emp" aria-label="Permalink to &quot;EMP&quot;">​</a></h3><p>通过官方仓库 <a href="https://github.com/efoxTeam/emp" target="_blank" rel="noreferrer">EMP</a>，中<code>projects</code> 里面的示例，体验了一下。</p><p>整体体验下来，开发比较流畅，但是文档目前不太完善。</p><p>主要原理是通过 <a href="https://webpack.js.org/" target="_blank" rel="noreferrer">webpack5</a> 的 <a href="https://webpack.js.org/concepts/module-federation/" target="_blank" rel="noreferrer">module-federation</a> 来加载远程模块。</p><p>因此高度依赖 <a href="https://webpack.js.org/" target="_blank" rel="noreferrer">webpack5</a>，对于其它打包工具,目前还不能很好的兼容。如果仅仅是当做路由框架，也是可行的。</p><p>因为直接暴露模块，因此没有通信和生命周期的的问题。但是样式隔离问题依旧存在，全局变量污染问题也存在。</p><p>下一个 <a href="https://github.com/single-spa/single-spa" target="_blank" rel="noreferrer">Single-SPA</a></p><h3 id="single-spa" tabindex="-1">Single-SPA <a class="header-anchor" href="#single-spa" aria-label="Permalink to &quot;Single-SPA&quot;">​</a></h3><p>粗略体验，文档完善，社区也很活跃。而且有 <a href="https://single-spa.js.org/docs/ssr-overview" target="_blank" rel="noreferrer">SSR</a> 方案。</p><p><a href="https://github.com/single-spa/single-spa" target="_blank" rel="noreferrer">Single-SPA</a> 整个文档，都在强调 <a href="https://github.com/single-spa/single-spa" target="_blank" rel="noreferrer">Single-SPA</a> 是一种思路，具体实现方案，可自行选择。例如 <a href="https://github.com/umijs/qiankun" target="_blank" rel="noreferrer">qiankun</a> 和 <a href="https://github.com/efoxTeam/emp" target="_blank" rel="noreferrer">EMP</a> 都可看作其一种具体的实现方案。</p><p><a href="https://github.com/single-spa/single-spa" target="_blank" rel="noreferrer">Single-SPA</a> 建议用加载 运行时模块(runtime module) 的方式，来组织「微前端」中不同的服务，例如用，尚在提案阶段的 <a href="https://github.com/WICG/import-maps" target="_blank" rel="noreferrer">import-maps</a>，<a href="https://caniuse.com/import-maps" target="_blank" rel="noreferrer">import-maps 兼容性</a> 或者 <a href="https://webpack.js.org/concepts/module-federation/" target="_blank" rel="noreferrer">webpack-module-federation</a> 功能。</p><p>官方会在处理「微前端」相关问题时，都会推荐一种实现方案，具体方案建议阅读 <a href="https://github.com/single-spa/single-spa" target="_blank" rel="noreferrer">Single-SPA</a> 文档。</p><p>下一个 <a href="https://github.com/umijs/qiankun" target="_blank" rel="noreferrer">QianKun</a>，一个 <a href="https://github.com/single-spa/single-spa" target="_blank" rel="noreferrer">Single-SPA</a> 的具体实现方案。</p><h3 id="qiankun" tabindex="-1">QianKun <a class="header-anchor" href="#qiankun" aria-label="Permalink to &quot;QianKun&quot;">​</a></h3><p>通过官方的示例，简单体验了一下，相比前几个框架，这个体验下来是最流畅的。接下来，看看 <a href="https://github.com/umijs/qiankun" target="_blank" rel="noreferrer">QianKun</a> 中具体细节的一些处理方式。</p><p>关于资源加载部分，乾坤用的是 <a href="https://github.com/kuitos/import-html-entry" target="_blank" rel="noreferrer">import-html-entry</a> 的方式。配置就比较简单，直接给一个 <code>html</code> 入口即可。基本原理是把 html 中的标签转移在当前需要挂载的 <code>div</code> 上，如果浏览器环境支持 <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM" target="_blank" rel="noreferrer">Shadow-Dom</a>，则会用 <code>shadow dom</code> 来处理环境隔离，具体代码 <a href="https://github.com/umijs/qiankun/blob/972872f5fe62ca87b6911fbe8c62b389ac65f9c5/src/loader.ts#L75-L92" target="_blank" rel="noreferrer">source: Shadow-Dom</a>。</p><p>关于 <code>JavaScript</code> 执行环境，用的是 <a href="https://github.com/kuitos/import-html-entry" target="_blank" rel="noreferrer">import-html-entry</a> 的 <code>sandbox</code>，可保证不会污染全局变量。</p><p>关于样式隔离，则是通过自动给每一条样式添加一个 <code>scoped</code> 来实现隔离 <a href="https://github.com/umijs/qiankun/blob/972872f5fe62ca87b6911fbe8c62b389ac65f9c5/src/loader.ts#L95-L105" target="_blank" rel="noreferrer">source: Css-Scoped</a>，如果支持 <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM" target="_blank" rel="noreferrer">Shadow-Dom</a> 则不需要处理。</p><p>虽然支持 <code>shadow-dom</code>，但是建议不要使用 <code>shadow dom</code>，因为这会导致一些其它问题，例如第三方库中的 <code>Modal</code> 无法使用。</p><p>关于通信，<a href="https://github.com/umijs/qiankun" target="_blank" rel="noreferrer">QianKun</a> 实现了一套基本的状态管理方案 <a href="https://qiankun.umijs.org/api#initglobalstatestate" target="_blank" rel="noreferrer">Global-State</a>。具体原理，则是通过 全局 实例来处理的。<a href="https://github.com/umijs/qiankun/blob/HEAD/src/globalState.ts#" target="_blank" rel="noreferrer">source: Global-State</a></p><h3 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h3><p>准确来讲，仅有三个框架，因为 <a href="https://github.com/single-spa/single-spa" target="_blank" rel="noreferrer">Single-SPA</a> 主要介绍的是理念。</p><p>三个框架，各有千秋，但是 <a href="https://github.com/umijs/qiankun" target="_blank" rel="noreferrer">QianKun</a> 目前看来是相对比较好的方案，代码侵入少，环境隔离好。</p><p>具体的代码看了，接下来聊聊 「微前端」 具体解决了哪些问题。</p><h2 id="微前端需要解决的问题" tabindex="-1">微前端需要解决的问题 <a class="header-anchor" href="#微前端需要解决的问题" aria-label="Permalink to &quot;微前端需要解决的问题&quot;">​</a></h2><ol><li>服务更新问题</li><li>通信问题</li><li>样式隔离问题</li><li>环境隔离问题</li></ol><h3 id="服务更新问题" tabindex="-1">服务更新问题 <a class="header-anchor" href="#服务更新问题" aria-label="Permalink to &quot;服务更新问题&quot;">​</a></h3><p>关于更新的问题，进一步的问题可以提炼成：关于「微前端」中的不同服务，是否需要主应用来控制版本呢？</p><p>我认为这个答案是否定的，不需要主应用来控制里面服务的版本，也就是主应用里面的服务，无论什么时候都是最新的版本，主应用不关心里面的服务的版本。</p><p>由此，也可确定，服务之间，应该尽可能的减少通信。因为频繁的通信，即可导致耦合较大，就必须要有版本控制，否则，出问题的概率就比较大。</p><h3 id="通信问题" tabindex="-1">通信问题 <a class="header-anchor" href="#通信问题" aria-label="Permalink to &quot;通信问题&quot;">​</a></h3><p>有上一个问题的讨论结果，可得出，通信功能只要满足能用即可。并不要实现特别复杂的机制。</p><p>由不同「微前端」方案，也衍生出不同的通信方案：</p><ol><li><a href="https://github.com/SAP/luigi" target="_blank" rel="noreferrer">Luigi</a> 用到的 <code>window.postMessage</code></li><li><a href="https://github.com/single-spa/single-spa" target="_blank" rel="noreferrer">Single-SPA</a> 提到的 <code>window.addEventListener/dispatchEvent</code> <a href="https://single-spa.js.org/docs/recommended-setup/#ui-state" target="_blank" rel="noreferrer">source</a></li><li><a href="https://github.com/efoxTeam/emp" target="_blank" rel="noreferrer">EMP</a> 中自定义的模块，则可直接暴露函数</li><li><a href="https://github.com/umijs/qiankun" target="_blank" rel="noreferrer">QianKun</a> 中自己实现一个 <a href="https://qiankun.umijs.org/api#initglobalstatestate" target="_blank" rel="noreferrer">Global-State</a></li></ol><h3 id="样式隔离问题" tabindex="-1">样式隔离问题 <a class="header-anchor" href="#样式隔离问题" aria-label="Permalink to &quot;样式隔离问题&quot;">​</a></h3><p>推荐阅读 <a href="https://single-spa.js.org/docs/ecosystem-css" target="_blank" rel="noreferrer">Single-SPA-CSS</a>，样式隔离的一些指导和分析。</p><p><a href="https://single-spa.js.org/docs/ecosystem-css" target="_blank" rel="noreferrer">Single-SPA-CSS</a> 推荐 一份公用的样式，然后每个服务的样式，都自己去借助工具或者一些技术做到自我隔离。例如 <a href="https://github.com/css-modules/css-modules" target="_blank" rel="noreferrer">css-module</a> 技术，或者 <code>Vue</code> 的 <code>scoped</code> 方案。</p><p>但如果使用像 <a href="https://github.com/SAP/luigi" target="_blank" rel="noreferrer">Luigi</a> 这样利用 <code>iframe</code> 的框架，则天然支持样式隔离。</p><p>或者是 <a href="https://github.com/umijs/qiankun" target="_blank" rel="noreferrer">QianKun</a> 那样，加载的时候，自动添加上一层 <code>scope</code>。</p><h3 id="环境隔离问题" tabindex="-1">环境隔离问题 <a class="header-anchor" href="#环境隔离问题" aria-label="Permalink to &quot;环境隔离问题&quot;">​</a></h3><p>环境隔离，主要问题是全局环境变量的问题。要处理这个问题，第一个想到的肯定就是，人工约定一个格式，先到先得。这种方式够用，但不够友好。</p><p>如果是用 <code>iframe</code>，则没有这个问题。</p><p>看 <a href="https://github.com/umijs/qiankun" target="_blank" rel="noreferrer">QianKun</a> 的源代码的时候，看到其用到了 <code>Sandbox</code> 这个东西。仔细读了读，实际上是通过 <a href="https://github.com/kuitos/import-html-entry" target="_blank" rel="noreferrer">import-html-entry</a> 的 <a href="https://github.com/kuitos/import-html-entry/blob/ab3e788ee868177ecf407f79b00d52ca2e2cdd47/src/index.js#L52-L63" target="_blank" rel="noreferrer">source: getExecutableScript</a> 实现的。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes vitesse-dark vitesse-light vp-code" tabindex="0"><code><span class="line"><span style="--shiki-dark:#CB7676;--shiki-light:#AB5959;">function</span><span style="--shiki-dark:#80A665;--shiki-light:#59873A;"> getExecutableScript</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">(</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">scriptSrc</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">,</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> scriptText</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">,</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> proxy</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">,</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> strictGlobal</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">)</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> {</span></span>
<span class="line"><span style="--shiki-dark:#CB7676;--shiki-light:#AB5959;">  const</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> sourceUrl</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> =</span><span style="--shiki-dark:#80A665;--shiki-light:#59873A;"> isInlineCode</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">(</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">scriptSrc</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">)</span><span style="--shiki-dark:#CB7676;--shiki-light:#AB5959;"> ?</span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;"> &#39;&#39;</span><span style="--shiki-dark:#CB7676;--shiki-light:#AB5959;"> :</span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;"> \`</span><span style="--shiki-dark:#C98A7D;--shiki-light:#B56959;">//# sourceURL=</span><span style="--shiki-dark:#4D9375;--shiki-light:#1E754F;">\${</span><span style="--shiki-dark:#C98A7D;--shiki-light:#B56959;">scriptSrc</span><span style="--shiki-dark:#4D9375;--shiki-light:#1E754F;">}</span><span style="--shiki-dark:#C99076;--shiki-light:#A65E2B;">\\n</span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;">\`</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-dark:#758575DD;--shiki-light:#A0ADA0;">  // 通过这种方式获取全局 window，因为 script 也是在全局作用域下运行的，所以我们通过 window.proxy 绑定时也必须确保绑定到全局 window 上</span></span>
<span class="line"><span style="--shiki-dark:#758575DD;--shiki-light:#A0ADA0;">  // 否则在嵌套场景下， window.proxy 设置的是内层应用的 window，而代码其实是在全局作用域运行的，会导致闭包里的 window.proxy 取的是最外层的微应用的 proxy</span></span>
<span class="line"><span style="--shiki-dark:#CB7676;--shiki-light:#AB5959;">  const</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> globalWindow</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> =</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> (</span><span style="--shiki-dark:#4C9A91;--shiki-light:#2F798A;">0</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">,</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> eval</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">)(</span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;">&#39;</span><span style="--shiki-dark:#C98A7D;--shiki-light:#B56959;">window</span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;">&#39;</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">)</span></span>
<span class="line"><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">  globalWindow</span><span style="--shiki-dark:#666666;--shiki-light:#999999;">.</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;">proxy</span><span style="--shiki-dark:#666666;--shiki-light:#999999;"> =</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> proxy</span></span>
<span class="line"><span style="--shiki-dark:#758575DD;--shiki-light:#A0ADA0;">  // TODO 通过 strictGlobal 方式切换 with 闭包，待 with 方式坑趟平后再合并</span></span>
<span class="line"><span style="--shiki-dark:#4D9375;--shiki-light:#1E754F;">  return</span><span style="--shiki-dark:#BD976A;--shiki-light:#B07D48;"> strictGlobal</span></span>
<span class="line"><span style="--shiki-dark:#CB7676;--shiki-light:#AB5959;">    ?</span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;"> \`</span><span style="--shiki-dark:#C98A7D;--shiki-light:#B56959;">;(function(window, self, globalThis){with(window){;</span><span style="--shiki-dark:#4D9375;--shiki-light:#1E754F;">\${</span><span style="--shiki-dark:#C98A7D;--shiki-light:#B56959;">scriptText</span><span style="--shiki-dark:#4D9375;--shiki-light:#1E754F;">}</span><span style="--shiki-dark:#C99076;--shiki-light:#A65E2B;">\\n</span><span style="--shiki-dark:#4D9375;--shiki-light:#1E754F;">\${</span><span style="--shiki-dark:#C98A7D;--shiki-light:#B56959;">sourceUrl</span><span style="--shiki-dark:#4D9375;--shiki-light:#1E754F;">}</span><span style="--shiki-dark:#C98A7D;--shiki-light:#B56959;">}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);</span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;">\`</span></span>
<span class="line highlighted"><span style="--shiki-dark:#CB7676;--shiki-light:#AB5959;">    :</span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;"> \`</span><span style="--shiki-dark:#C98A7D;--shiki-light:#B56959;">;(function(window, self, globalThis){;</span><span style="--shiki-dark:#4D9375;--shiki-light:#1E754F;">\${</span><span style="--shiki-dark:#C98A7D;--shiki-light:#B56959;">scriptText</span><span style="--shiki-dark:#4D9375;--shiki-light:#1E754F;">}</span><span style="--shiki-dark:#C99076;--shiki-light:#A65E2B;">\\n</span><span style="--shiki-dark:#4D9375;--shiki-light:#1E754F;">\${</span><span style="--shiki-dark:#C98A7D;--shiki-light:#B56959;">sourceUrl</span><span style="--shiki-dark:#4D9375;--shiki-light:#1E754F;">}</span><span style="--shiki-dark:#C98A7D;--shiki-light:#B56959;">}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);</span><span style="--shiki-dark:#C98A7D77;--shiki-light:#B5695977;">\`</span></span>
<span class="line"><span style="--shiki-dark:#666666;--shiki-light:#999999;">}</span></span></code></pre></div><p>核心代码，就是 <code>;(function(window, self, globalThis){;\${scriptText}\\n\${sourceUrl}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy)</code> 这一句了。在运行代码的时候，通过闭包机制，替换 <code>window,self,globalThis</code> 三个变量。</p><p>我个人认为，这个方面就看情况了，如果开箱支持，那就用。如果不支持，那也没有必要非得用这种方式，就「约定」的方式也挺好的， 也没什么大问题。</p><h2 id="需要微前端吗" tabindex="-1">需要微前端吗？ <a class="header-anchor" href="#需要微前端吗" aria-label="Permalink to &quot;需要微前端吗？&quot;">​</a></h2><p>现在，对微前端有了一个整体的认识，我们真的需要微前端吗？</p><p>这个问题，每个人的看法不一样，<strong>这里我就随便聊聊，看看就完事了，当真就输了。是否真的需要，还需自己考虑。</strong></p><p>整体来讲，「微前端」在我看来，应用场景有限，入门需要一定的成本，虽然可以分离业务，也有很多优点。</p><p>但是缺点也很明显，成本上去了，团队交流成本，开发成本都上升了。举一个小例子，有个需求需要应用 A 支持一下，但是应用 A 是其它团队负责，原本估计一天就能搞定的事情，经过交流，确认，最后开发，要三天才能搞定。 在 <a href="https://www.yuque.com/kuitos/gky7yw/rhduwc" target="_blank" rel="noreferrer">qiankun-技术圆桌</a> 中也提到过，「微前端」的目的是为了支持不同的技术栈（这点可推导出是为了支持不同的开发团队）。</p><p>因此，在我看来，在项目没有大到一定程度（必须要跨团队）的时候，没必要考虑「微前端」。</p><h2 id="推荐阅读" tabindex="-1">推荐阅读 <a class="header-anchor" href="#推荐阅读" aria-label="Permalink to &quot;推荐阅读&quot;">​</a></h2><ul><li><a href="https://micro-frontends.org/" target="_blank" rel="noreferrer">micro-frontends</a>，一篇对「微前端」简单介绍的文章。</li><li><a href="https://martinfowler.com/articles/micro-frontends.html" target="_blank" rel="noreferrer">martinfowler-micro-frontends</a>，分析「微前端」的优劣势，和一些实现方案以及细节处理方式。</li><li><a href="https://www.yuque.com/kuitos/gky7yw/rhduwc" target="_blank" rel="noreferrer">qiankun-技术圆桌</a>，探讨「微前端」的目的，使命。</li><li><a href="https://single-spa.js.org/docs/microfrontends-concept" target="_blank" rel="noreferrer">Single-SPA Concept</a>，「微前端」概念介绍，以及开发方向指导。</li><li><a href="https://single-spa.js.org/docs/recommended-setup" target="_blank" rel="noreferrer">Single-SPA Recommended-setup</a>，「微前端」推荐实现方案。</li></ul><h2 id="参考文献" tabindex="-1">参考文献 <a class="header-anchor" href="#参考文献" aria-label="Permalink to &quot;参考文献&quot;">​</a></h2><ul><li><a href="https://micro-frontends.org/" target="_blank" rel="noreferrer">micro-frontends</a></li><li><a href="https://martinfowler.com/articles/micro-frontends.html" target="_blank" rel="noreferrer">martinfowler-micro-frontends</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" target="_blank" rel="noreferrer">web-component</a></li><li><a href="https://www.yuque.com/kuitos/gky7yw/rhduwc" target="_blank" rel="noreferrer">qiankun-技术圆桌</a></li><li><a href="https://webpack.js.org/concepts/module-federation/" target="_blank" rel="noreferrer">webpack-module-federation</a></li><li><a href="https://github.com/SAP/luigi" target="_blank" rel="noreferrer">luigi</a></li><li><a href="https://github.com/efoxTeam/emp" target="_blank" rel="noreferrer">emp</a></li><li><a href="https://github.com/single-spa/single-spa" target="_blank" rel="noreferrer">single-spa</a></li><li><a href="https://github.com/umijs/qiankun" target="_blank" rel="noreferrer">qiankun</a></li><li><a href="https://webpack.js.org/" target="_blank" rel="noreferrer">webpack5</a></li><li><a href="https://single-spa.js.org/docs/ecosystem-css" target="_blank" rel="noreferrer">single-spa-css</a></li><li><a href="https://github.com/kuitos/import-html-entry" target="_blank" rel="noreferrer">import-html-entry</a></li><li><a href="https://qiankun.umijs.org/api#initglobalstatestate" target="_blank" rel="noreferrer">global-state</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM" target="_blank" rel="noreferrer">shadow-dom</a></li></ul>`,99)]))}const c=i(t,[["render",l]]);export{d as __pageData,c as default};
